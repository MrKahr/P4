/*** TEMPLATES ***/

Template Card CONTAINS {
  String color;
  Integer value;
}

Template Deck CONTAINS {
  Card[] cards;
  Integer size;
}

Template Player CONTAINS {
  String name;
  Deck hand;
}

Template Board CONTAINS {
    Player[] players;
    Deck[] decks;       // Index 0 is draw pile, index 1 is discard pile
    Player activePlayer;
}

/*
// Reorders cards in a deck randomly
Action shuffle(Deck deckSource) // Must implement

// Draw till deckSource is empty
Action drawAll(Deck deckSource, Deck deckTarget) // Must implement

// Do stuff on game start
Action GameStart(State startingState) // Must implement
*/



// ------ WORKING --------- //
Action draw(Deck deckSource, Deck deckTarget, Integer valueOfCardsTodraw) RESULTS IN Deck[] {
    Deck[] decks;

    FOR(Integer i IS 0; i LESS THAN valueOfCardsTodraw; i IS i + 1){
        Card card IS deckSource.cards[deckSource.size];
        deckSource.size IS deckSource.size - 1;

        deckTarget.cards[deckTarget.size] IS card;
        deckTarget.size IS deckTarget.size + 1;
    }
    decks[0] IS deckSource;
    decks[1] IS deckTarget;
    RESULT IN decks;
}


// ------ WORKING --------- //
Action storeBoard(Board board) RESULTS IN Board {
    RESULT IN board;
}


// This is presented to the user. Thus, it should only have primitives as paramenters
Action playCard(Card card) RESULTS IN Card {
    RESULT IN card;
}


// ------ WORKING --------- //
Action removeCard(Card cardToRemove, Deck targetDeck) RESULTS IN Deck {
    Deck newDeck IS NEW Deck{};
    Integer newDeckSize IS 0;

    FOR(Integer i IS 0; i GREATER OR EQUALS targetDeck.size; i IS i+1){
        Card targetCard IS targetDeck.cards[i];

        // Add card to new deck if it should be kept
        IF(targetCard.color NOT EQUALS cardToRemove.color AND targetCard.value NOT EQUALS cardToRemove.value){
            newDeck.cards[newDeckSize] IS targetCard;
            newDeck.size IS newDeckSize;
            newDeckSize IS newDeckSize + 1;
        }
    }
    RESULT IN newDeck;
}


Action addCard(Deck deck, Card card) RESULTS IN Deck {
    deck.cards[deck.size] IS card;
    deck.size IS deck.size + 1;
    RESULT IN deck;
}


// ------ WORKING --------- //
Action makeCards() RESULTS IN Deck {
    Deck resultDeck IS NEW Deck{};
    String[] colors IS ["red", "green", "yellow", "blue"];
    Integer[] values IS [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    FOR(Integer i IS 0; i LESS THAN 4; i IS i+1) {
        FOR(Integer j IS 0; j LESS THAN 10; j IS j+1) {
            resultDeck.cards[resultDeck.size] IS NEW Card{colors[i]; values[j];};
            resultDeck.size IS resultDeck.size + 1;
        }
    }
    RESULT IN resultDeck;
}


Action declareWinner(Player winner) {
    write("Winner found");
}


// ------ WORKING --------- //
Action showBoard(Board board) {
    String s IS "It is " + board.activePlayer.name + "'s turn. Hand: \n";
    FOR(Integer i IS 0; i LESS THAN board.activePlayer.hand.size; i IS i+1) {
        s IS s + "[" + i + "]" + " card: " + "{" + "Value: " + board.activePlayer.hand.cards[i].value + ", Color: " + board.activePlayer.hand.cards[i].color + "}\n";
    }
    write(s);
}


// ------ WORKING --------- //
Action containsValidCard(Deck hand, Card topCard) RESULTS IN Boolean {
    Boolean result IS false;
    FOR(Integer i IS 0; i LESS THAN hand.size; i IS i+1) {
        IF(hand.cards[i].color EQUALS topCard.color OR hand.cards[i].value EQUALS topCard.value) {
            result IS true;
        }
    }
    RESULT IN result;
}


// ------ WORKING --------- //
Action updateActivePlayer(Board board) {
    IF(board.activePlayer.name EQUALS board.players[0].name) {
        board.activePlayer IS board.players[1];
    } ELSE {
        board.activePlayer IS board.players[0];
    }
    storeBoard(board);
}



/*** RULES ***/

/*  Implement shuffle
Rule mustShuffle WHEN [draw] IF (storeBoard.RESULT.decks[1].size LESS THAN 1){
    Board board IS storeBoard.RESULT;
    shuffle(board.decks[0]);
    drawAll(board.decks[0], board.decks[1]);
    storeBoard(board);
}
*/

/*
Rule drawUntilValid WHEN [draw, setState] IF ("Play" EQUALS setState.RESULT AND NOT containsValidCard(storeBoard.RESULT.activePlayer.hand, storeBoard.RESULT.decks[0].cards[storeBoard.RESULT.decks[0].size])){
    Board board IS storeBoard.RESULT;
    draw(board.decks[1], board.activePlayer.hand, 1);
    storeBoard(board);
}
*/

Rule playsValidCard WHEN [playCard] IF(playCard.RESULT.color EQUALS storeBoard.RESULT.decks[0].cards[storeBoard.RESULT.decks[0].size].color OR playCard.RESULT.value EQUALS storeBoard.RESULT.decks[0].cards[storeBoard.RESULT.decks[0].size].value){
    Board board IS storeBoard.RESULT;
    removeCard(playCard.RESULT, board.activePlayer.hand);
    updateActivePlayer(board);
    storeBoard(board);
}


Rule winner WHEN [playCard] IF (storeBoard.RESULT.activePlayer.hand.size LESS THAN 1) {
    setState("End");
}


Rule startTurn WHEN [setState] IF ("Play" EQUALS setState.RESULT){
    Board board IS storeBoard.RESULT;
    showBoard(board);
    playCard(board.activePlayer.hand.cards[0]); //StringToInt(ReadAction())
}


/*** STATES ***/

// Global variable keeps track of current state

State Start ALLOWS [draw]//, shuffle]

// Allowable actions are declared - error if wrong actions performed
// Implement "ALL" which means all actions are allowed

State Play ALLOWS [playCard]// [ALL]
State End ALLOWS []//shuffle]




/*** MAIN GAME ***/

Player playerOne IS NEW Player {"John"; NEW Deck{};};
Player playerTwo IS NEW Player {"Userman"; NEW Deck{};};

Board b1 IS NEW Board {
    [playerOne, playerTwo];
    [makeCards()];  // Index 0 is draw pile, index 1 is discard pile
    playerOne;
};


//shuffle(storeBoard.RESULT.decks[1]);

// Player 1
b1.decks[0] IS draw(b1.decks[0], b1.players[0].hand, 7)[0]; // Index 0 is source deck
b1.players[0].hand IS draw.RESULT[1];                       // Index 1 is target deck

// Player 2
b1.decks[1] IS draw(b1.decks[0], b1.players[1].hand, 7)[0]; // Index 0 is source deck
b1.players[1].hand IS draw.RESULT[1];                       // Index 1 is target deck


Card testCard IS NEW Card{"fishg"; 5;};

Deck testdeck IS NEW Deck{[testCard]; 1;};


Boolean shouldValid IS containsValidCard(testdeck, testCard);

testdeck IS removeCard(testCard, testdeck);

Boolean invalid IS containsValidCard(testdeck, testCard);

storeBoard(b1);
showBoard(storeBoard.RESULT);

updateActivePlayer(storeBoard.RESULT);

showBoard(storeBoard.RESULT);

setState("End");