/*** TEMPLATES ***/

Template Card CONTAINS {
  String color;
  Integer value;
}

Template Deck CONTAINS {
  Card[] cards;
}

Template Player CONTAINS {
  String name;
  Deck hand;
}

Template Board CONTAINS {
    Player[] players;
    Deck[] decks;       // Index 0 is draw pile, index 1 is discard pile
    Player activePlayer;
}

/*
// Reorders cards in a deck randomly
Action shuffle(Deck deckSource) RESULTS IN Deck {
    RESULT IN
}

// Do stuff on game start
Action GameStart(State startingState) // Must implement
*/


// Should work
// Add card to deck
Action addCard(Deck deck, Card card) RESULTS IN Deck {
    deck.cards[size(deck.cards)] IS card;
    RESULT IN deck;
}


// ------ WORKING --------- //
Action removeCard(Card cardToRemove, Deck targetDeck) RESULTS IN Deck {
    Deck newDeck IS NEW Deck{};

    FOR(Integer i IS 0; i LESS THAN size(targetDeck.cards); i IS i+1){
        Card targetCard IS targetDeck.cards[i];

        // Add card to new deck if it should be kept
        IF(targetCard.color NOT EQUALS cardToRemove.color AND targetCard.value NOT EQUALS cardToRemove.value){
            newDeck IS addCard(newDeck, targetCard);
        }
    }
    RESULT IN newDeck;
}


// ------ WORKING --------- //
Action draw(Deck deckSource, Deck deckTarget, Integer valueOfCardsTodraw) RESULTS IN Deck[] {
    Deck[] decks;

    FOR(Integer i IS 0; i LESS THAN valueOfCardsTodraw; i IS i + 1){
        Card card IS deckSource.cards[size(deckSource.cards) - 1]; // Get reference to card
        deckSource IS removeCard(card, deckSource); // Remove card from source
        deckTarget IS addCard(deckTarget, card);    // Add card to target
    }
    decks[0] IS deckSource;
    decks[1] IS deckTarget;
    RESULT IN decks;
}


// ------ WORKING --------- //
Action storeBoard(Board board) RESULTS IN Board {
    RESULT IN board;
}


// klar til testing
Action playCard(Integer choice) RESULTS IN Card {
    Board board IS storeBoard.RESULT;
    Card card;
    Integer handSize IS size(board.activePlayer.hand.cards) - 1;
    IF(choice GREATER THAN handSize){
        card IS board.activePlayer.hand.cards[choice];
    } ELSE {
        write("Invalid input. Expected input in range " + 0 + "-" + handSize);
    }
    RESULT IN card;
}


// ------ WORKING --------- //
Action makeCards() RESULTS IN Deck {
    Deck resultDeck IS NEW Deck{};
    String[] colors IS ["red", "green", "yellow", "blue"];
    Integer[] values IS [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    FOR(Integer i IS 0; i LESS THAN 4; i IS i+1) {
        FOR(Integer j IS 0; j LESS THAN 10; j IS j+1) {
            resultDeck IS addCard(resultDeck, NEW Card{colors[i]; values[j];});
        }
    }
    RESULT IN resultDeck;
}


// ------ WORKING --------- //
Action declareWinner(Player player) {
    write("Winner found: " + player.name + ". Congratulations!");
}


// ------ WORKING --------- //
Action showBoard(Board board) {
    String s IS "It is " + board.activePlayer.name + "'s turn. Hand: \n";
    FOR(Integer i IS 0; i LESS THAN size(board.activePlayer.hand.cards); i IS i+1) {
        s IS s + "[" + i + "]" + " card: " + "{" + "Value: " + board.activePlayer.hand.cards[i].value + ", Color: " + board.activePlayer.hand.cards[i].color + "}\n";
    }
    write(s);
}


// ------ WORKING --------- //
Action containsValidCard(Deck hand, Card topCard) RESULTS IN Boolean {
    Boolean result IS false;
    FOR(Integer i IS 0; i LESS THAN size(hand.cards); i IS i+1) {
        IF(hand.cards[i].color EQUALS topCard.color OR hand.cards[i].value EQUALS topCard.value) {
            result IS true;
        }
    }
    RESULT IN result;
}


// ------ WORKING --------- //
Action updateActivePlayer(Board board) {
    IF(board.activePlayer.name EQUALS board.players[0].name) {
        board.activePlayer IS board.players[1];
    } ELSE {
        board.activePlayer IS board.players[0];
    }
    storeBoard(board);
}



/*** RULES ***/

/*  Implement shuffle
Rule mustShuffle WHEN [draw] IF (size(storeBoard.RESULT.decks[0].cards) LESS THAN 1){
    Board board IS storeBoard.RESULT;
    shuffle(board.decks[1]);
    drawAll(board.decks[1], board.decks[0], size(board.decks[1]));
    storeBoard(board);
}
*/


Rule drawUntilValid WHEN [draw, setState] IF (
    "Play" EQUALS setState.RESULT AND
    NOT containsValidCard(
        storeBoard.RESULT.activePlayer.hand,
        storeBoard.RESULT.decks[0].cards[size(storeBoard.RESULT.decks[0].cards) - 1]
        )
    ){
    Board board IS storeBoard.RESULT;
    draw(board.decks[1], board.activePlayer.hand, 1);
    storeBoard(board);
}


Rule playsValidCard WHEN [playCard] IF (
    playCard.RESULT.color EQUALS storeBoard.RESULT.decks[0].cards[size(storeBoard.RESULT.decks[0].cards) - 1].color
    OR playCard.RESULT.value EQUALS storeBoard.RESULT.decks[0].cards[size(storeBoard.RESULT.decks[0].cards) - 1].value
    ){
    Board board IS storeBoard.RESULT;
    removeCard(playCard.RESULT, board.activePlayer.hand);
    updateActivePlayer(board);
    storeBoard(board);
}


Rule winner WHEN [playCard] IF (size(storeBoard.RESULT.activePlayer.hand.cards) LESS THAN 1) {
    declareWinner(storeBoard.RESULT.activePlayer);
    setState("End");
}


Rule startTurn WHEN [setState] IF ("Play" EQUALS setState.RESULT){
    Board board IS storeBoard.RESULT;
    showBoard(board);
}


/*** STATES ***/

// Global variable keeps track of current state

State Start ALLOWS [draw]

// Allowable actions are declared - error if wrong actions performed
// Implement "ALL" which means all actions are allowed

State Play ALLOWS [playCard]
State End ALLOWS []




/*** MAIN GAME ***/

Player playerOne IS NEW Player {"John"; NEW Deck{};};
Player playerTwo IS NEW Player {"Userman"; NEW Deck{};};

Board b1 IS NEW Board {
    [playerOne, playerTwo];
    [makeCards()];  // Index 0 is draw pile, index 1 is discard pile
    playerOne;
};


//shuffle(storeBoard.RESULT.decks[1]);

// Player 1 - draw cards from board's draw deck and update draw deck to reflect drawn cards
b1.decks[0] IS draw(b1.decks[0], b1.players[0].hand, 4)[0]; // Index 0 in actionCall is source deck

// Player 1 - assign drawn cards to the player's hand
b1.players[0].hand IS draw.RESULT[1];                       // Index 1 in actionCall is target deck

// Player 2 - draw cards from board's draw deck and update draw deck to reflect drawn cards
b1.decks[0] IS draw(b1.decks[0], b1.players[1].hand, 4)[0]; // Index 0 in actionCall is source deck

// Player 2 - assign drawn cards to the player's hand
b1.players[1].hand IS draw.RESULT[1];                       // Index 1 in actionCall is target deck



Card testCard IS NEW Card{"fishg"; 5;};

Deck testdeck IS NEW Deck{[testCard];};


Boolean shouldValid IS containsValidCard(testdeck, testCard);

testdeck IS removeCard(testCard, testdeck);

Boolean invalid IS containsValidCard(testdeck, testCard);


storeBoard(b1);
setState("End");